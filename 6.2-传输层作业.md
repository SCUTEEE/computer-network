6

另一个标准是：客户端的初始化时间。如果客户端的初始化时间很长（不妨假设无限长），那么显然客户端应该全程活跃。

9

存在死锁。假设 A 向 B 发出连接请求，B 收到请求后发送应答，但 A 没收到应答。此时，B 已经建立了连接，而 A 还没有。故这时 B 会传送数据，而 A 会忽略数据。B 发送的分组超时后，会重复发送分组，导致死锁。

15 不够，因为无法通过 IP 数据包知道分组要给哪个进程。

22

默认段 536 bytes 加上TCP 20 bytes，即 576 bytes

26

不可能，因为不同连接通过端口号来区分，如果两端的端口号相同，那么就是同一条连接


28

IP 分组的数据段最大为 65515 bytes，TCP 头至少要 20 bytes，所以 TCP 数据最大为 65515-20=65495

30

2*2*2*2*2=32,min{32,24}=24KB

31

8KB

33

RTT 为 20ms，即 20ms 发一个窗口，则最大吞吐量为 65535*8*50=26.2 Mb/s，26.2Mb/1Gb=2.6%

36

30s 内，最多发送 2^8=256 个段，每个段 128 bytes，故最大数据率为 2*256*128*8=8.7kbps

第六章补充习题：

补1：请描述TCP 连接建立的三次握手过程（必要的话，可配图说明）。

1. A 发送序号 x 的 CONNECTION REQUEST，即 seq=x
2. B 回应一个 ACK，并宣告自己的序号 y，即 seq=y,ack=x+1
3. A 对 B 选择的 y 进行确认，即 seq=x+1,ack=y+1



补2：请描述TCP 拥塞控制的方法。

1. TCP 通过监视超时来判断拥塞
2. TCP 通过动态维护窗口大小来进行拥塞控制。接收方根据缓冲区指定窗口大小（接受窗口），而网络容量也对窗口有限制（拥塞窗口）。发送方则遵守这两个限制，使得接收端不会溢出。


补3：如何避免更新窗口的丢失而产生的死锁？

发送端会采用一个 持续计时器 间歇性的查询接收端，看其窗口是否已经增长。 持续计时器会触发窗口探测的传输，强制要求接收端返回ACK(包含可用窗口大小)。窗口探测(一种数据段)包含一个字节的数据，采用TCP可靠传输(丢失重传)，因此避免由于窗口更新丢失导致的死锁。当TCP持续计时器超时就会触发窗口探测的发送。其中一个字节的数据能否被接收取决于接收端缓存的大小

补4：根据自己的理解，全面比较UDP 和
TCP。

